//
// Created by ajahueym on 1/10/24.
//
#include <frc/system/plant/DCMotor.h>
#include <ntcore/networktables/NetworkTableInstance.h>
#include <ros/ros.h>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <cmath>

#include <boost/accumulators/accumulators.hpp>
#include <boost/accumulators/statistics.hpp>
#include <boost/accumulators/statistics/rolling_mean.hpp>

namespace ba = boost::accumulators;

auto make_accum(int window) {
    return ba::accumulator_set<
            double,
            ba::stats<ba::tag::rolling_mean>> (ba::tag::rolling_window::window_size = window);
}

namespace gazebo {
    class NTMotorPlugin : public ModelPlugin {
    public:
        NTMotorPlugin(): ModelPlugin() {
        }

        void Load(physics::ModelPtr model, sdf::ElementPtr sdf) override {
            this->model = model;

            if(!ros::isInitialized()){
                ROS_FATAL_STREAM("Unable to load NTMotorPlugin, ROS is not initialized");
                return;
            }

            if(model->GetJointCount() == 0) {
                ROS_FATAL_STREAM("Unable to load NTMotorPlugin given to model with no joints!!!");
                return;
            }

            std::string modelName = model->GetName();
            std::string jointName;
            if (sdf->HasElement("joint_name")) {
                jointName = sdf->Get<std::string >("joint_name");
            }

            if(jointName.empty()){
                ROS_FATAL("NTMotorPlugin used in %s not given a joint_name!!!!", modelName.c_str());
                return;
            }


            controlledJoint = model->GetJoint(jointName);

            if(!controlledJoint) {
                ROS_FATAL("Joint %s does not exist in model %s!!!", jointName.c_str(), modelName.c_str());
                return;
            }

            if(sdf->HasElement("joint_axis")){
                jointAxis = sdf->Get<unsigned int>("joint_axis");
            }

            std::string motorModel;
            if (sdf->HasElement("motor_model")) {
                motorModel = sdf->Get<std::string >("motor_model");
            }

            if(motorModel.empty()){
                ROS_FATAL("NTMotorPlugin used in %s not given a FRC motor model!!!!", modelName.c_str());
                return;
            }

            if (sdf->HasElement("gear_ratio")) {
                gear_ratio = sdf->Get<double >("gear_ratio");
            }

            if (sdf->HasElement("motor_count")) {
                motorCount = sdf->Get<unsigned int >("motor_count");
            }

            if (sdf->HasElement("torque_axis")) {
                torqueAxis = sdf->Get<char>("torque_axis");
            }

            if(motorModel == "Kraken") {
                motor = frc::DCMotor::KrakenX60();
            } else if (motorModel == "NEO") {
                motor = frc::DCMotor::NEO();
            } else if (motorModel == "Falcon"){
                motor = frc::DCMotor::Falcon500();
            } else if (motorModel == "FalconFOC"){
                motor = frc::DCMotor::Falcon500FOC();
            } else if (motorModel == "Vortex"){
                motor = frc::DCMotor::NeoVortex();
            } else {
                ROS_FATAL("NTMotorPlugin used invalid FRC motor model %s!!!!", motorModel.c_str());
                return;
            }

            motor = motor.WithReduction(gear_ratio);

            /// We have the joint that is to be controlled, setup nt listeners and update
            updateConnection = event::Events::ConnectWorldUpdateEnd([this] { Update(); });

            ntInst = nt::NetworkTableInstance::GetDefault();
            ntInst.SetServer("127.0.0.1");
            std::stringstream  ntIdentity;
            ntIdentity << "nt_motor_plugin_" << modelName << "_" << jointName;
            ntInst.StartClient4(ntIdentity.str());

            const auto ntable = ntInst.GetTable(modelName)->GetSubTable(jointName);
            encoderSpeedEntry = ntable->GetEntry("encoder_speed");
            encoderPositionEntry = ntable->GetEntry("encoder_position");
            voltageEntry = ntable->GetEntry("voltage_applied");
            currentEntry = ntable->GetEntry("current");

            encoderSpeedEntry.SetDouble(0);
            encoderPositionEntry.SetDouble(0);
            voltageEntry.SetDouble(0);
            currentEntry.SetDouble(0);
        }

        void Update() {
            // Find out torque generated by motor
            const double jointSpeedRadPerS = controlledJoint->GetVelocity(jointAxis);
            const double appliedVoltage = voltageEntry.GetDouble(0);
            const auto current = motor.Current(units::radians_per_second_t (jointSpeedRadPerS), units::volt_t (appliedVoltage));

            currentEntry.SetDouble(current.to<double>());

            const auto torqueGenerated = motor.Torque(current);
            const double torqueToApply = torqueGenerated.value() * motorCount;
            ignition::math::Vector3d torque;

            switch (torqueAxis) {
                case 'z':
                    torque =  {0, 0, torqueToApply};
                    break;
                case 'x':
                    torque =  {torqueToApply, 0, 0};
                    break;
                case 'y':
                    torque =  {0, torqueToApply, 0};
                    break;
                default:
                    break;

            }

            controlledJoint->GetChild()->SetTorque(torque);

            double position = controlledJoint->Position(jointAxis);
            double rotations = position / (2.0 * M_PI) * gear_ratio;
            encoderPositionEntry.SetDouble(rotations);

            ///TODO: Delay by the same amount as the motors do
            double encoderSpeed = jointSpeedRadPerS  / (2.0 * M_PI) * gear_ratio;
            acc(encoderSpeed);
            encoderSpeedEntry.SetDouble(ba::rolling_mean(acc));
            ntInst.Flush();
        }

    private:
        frc::DCMotor motor = frc::DCMotor(0_V, 0_Nm, 0_A, 0_A, 0_rad_per_s);
        physics::JointPtr controlledJoint;
        unsigned int jointAxis = 0;
        unsigned int motorCount = 1;
        physics::ModelPtr model;
        event::ConnectionPtr updateConnection;
        nt::NetworkTableInstance ntInst;
        nt::NetworkTableEntry encoderSpeedEntry, encoderPositionEntry, voltageEntry, currentEntry;
        double gear_ratio = 1;
        char torqueAxis = 'z';

        ba::accumulator_set<double, ba::stats<ba::tag::rolling_mean>> acc = make_accum(100);

    };


    GZ_REGISTER_MODEL_PLUGIN(NTMotorPlugin);
}