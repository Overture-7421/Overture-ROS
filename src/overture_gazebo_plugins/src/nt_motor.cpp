//
// Created by ajahueym on 1/10/24.
//

#include <frc/system/plant/DCMotor.h>
#include <ntcore/networktables/NetworkTableInstance.h>
#include <ros/ros.h>
#include <gazebo/gazebo.hh>
#include <gazebo/physics/physics.hh>
#include <gazebo/common/common.hh>
#include <cmath>

namespace gazebo {
    class NTMotorPlugin : public ModelPlugin {
    public:
        NTMotorPlugin(): ModelPlugin() {

        }

        void Load(physics::ModelPtr model, sdf::ElementPtr sdf) override {
            this->model = model;

            if(!ros::isInitialized()){
                ROS_FATAL_STREAM("Unable to load NTMotorPlugin, ROS is not initialized");
                return;
            }

            if(model->GetJointCount() == 0) {
                ROS_FATAL_STREAM("Unable to load NTMotorPlugin given to model with no joints!!!");
                return;
            }

            std::string modelName = model->GetName();
            std::string jointName;
            if (sdf->HasElement("joint_name")) {
                jointName = sdf->Get<std::string >("joint_name");
            }

            if(jointName.empty()){
                ROS_FATAL("NTMotorPlugin used in %s not given a joint_name!!!!", modelName.c_str());
                return;
            }


            controlledJoint = model->GetJoint(jointName);

            if(!controlledJoint) {
                ROS_FATAL("Joint %s does not exist in model %s!!!", jointName.c_str(), modelName.c_str());
                return;
            }

            if(sdf->HasElement("joint_axis")){
                jointAxis = sdf->Get<unsigned int>("joint_axis");
            }

            std::string motorModel;
            if (sdf->HasElement("motor_model")) {
                motorModel = sdf->Get<std::string >("motor_model");
            }

            if(motorModel.empty()){
                ROS_FATAL("NTMotorPlugin used in %s not given a FRC motor model!!!!", modelName.c_str());
                return;
            }

            double gear_ratio = 1;
            if (sdf->HasElement("gear_ratio")) {
                gear_ratio = sdf->Get<double >("gear_ratio");
            }

            if(motorModel == "Kraken") {
                motor = frc::DCMotor::KrakenX60();
                codesPerRev = 2048;
            } else if (motorModel == "NEO") {
                motor = frc::DCMotor::NEO();
            } else if (motorModel == "Falcon"){
                motor = frc::DCMotor::Falcon500();
                codesPerRev = 2048;
            } else if (motorModel == "FalconFOC"){
                motor = frc::DCMotor::Falcon500FOC();
                codesPerRev = 2048;
            } else if (motorModel == "Vortex"){
                motor = frc::DCMotor::NeoVortex();
            } else {
                ROS_FATAL("NTMotorPlugin used invalid FRC motor model %s!!!!", motorModel.c_str());
                return;
            }

            motor = motor.WithReduction(gear_ratio);

            /// We have the joint that is to be controlled, setup nt listeners and an update
            updateConnection = event::Events::ConnectWorldUpdateEnd([this] { Update(); });

            ntInst = nt::NetworkTableInstance::GetDefault();
            const auto ntable = ntInst.GetTable(modelName)->GetSubTable(jointName);
            encoderSpeedEntry = ntable->GetEntry("encoder_speed");
            encoderPositionEntry = ntable->GetEntry("encoder_position");
            voltageEntry = ntable->GetEntry("voltage_applied");
            currentEntry = ntable->GetEntry("current");
        }

        void Update() {
            // Find out torque generated by motor
            const double jointSpeedRadPerS = controlledJoint->GetVelocity(jointAxis);
            const double appliedVoltage = voltageEntry.GetDouble(0);
            const auto current = motor.Current(units::radians_per_second_t (jointSpeedRadPerS), units::volt_t (appliedVoltage));

            currentEntry.SetDouble(current.to<double>());

            const auto torqueGenerated = motor.Torque(current);
            controlledJoint->SetForce(jointAxis, torqueGenerated.to<double>());


            double position = controlledJoint->Position(jointAxis);
            int encoderPosition = std::floor(position / (2.0 * M_PI) * codesPerRev);
            encoderPositionEntry.SetDouble(encoderPosition);

            /// Delay by the same amount as the motors do
            double encoderSpeed = jointSpeedRadPerS  / (2.0 * M_PI) * codesPerRev;
            encoderSpeedEntry.SetDouble(encoderSpeed);
        }

    private:
        frc::DCMotor motor = frc::DCMotor(0_V, 0_Nm, 0_A, 0_A, 0_rad_per_s);
        physics::JointPtr controlledJoint;
        unsigned int jointAxis = 0;
        physics::ModelPtr model;
        event::ConnectionPtr updateConnection;
        nt::NetworkTableInstance ntInst;
        nt::NetworkTableEntry encoderSpeedEntry, encoderPositionEntry, voltageEntry, currentEntry;
        unsigned int codesPerRev = 0;

    };


    GZ_REGISTER_MODEL_PLUGIN(NTMotorPlugin);
}